// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addJobSkill = `-- name: AddJobSkill :one

INSERT INTO job_skills (job_id, skill_id, is_required, proficiency_level)
VALUES ($1, $2, $3, $4)
RETURNING id, job_id, skill_id, is_required, proficiency_level, created_at
`

type AddJobSkillParams struct {
	JobID            int64                    `db:"job_id" json:"job_id"`
	SkillID          int64                    `db:"skill_id" json:"skill_id"`
	IsRequired       pgtype.Bool              `db:"is_required" json:"is_required"`
	ProficiencyLevel NullProficiencyLevelEnum `db:"proficiency_level" json:"proficiency_level"`
}

// Job Skills Queries
func (q *Queries) AddJobSkill(ctx context.Context, arg AddJobSkillParams) (JobSkill, error) {
	row := q.db.QueryRow(ctx, addJobSkill,
		arg.JobID,
		arg.SkillID,
		arg.IsRequired,
		arg.ProficiencyLevel,
	)
	var i JobSkill
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.SkillID,
		&i.IsRequired,
		&i.ProficiencyLevel,
		&i.CreatedAt,
	)
	return i, err
}

const addUserSkill = `-- name: AddUserSkill :one
INSERT INTO user_skills (user_id, skill_id, proficiency_level, years_of_experience)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, skill_id, proficiency_level, years_of_experience, created_at
`

type AddUserSkillParams struct {
	UserID            int64                    `db:"user_id" json:"user_id"`
	SkillID           int64                    `db:"skill_id" json:"skill_id"`
	ProficiencyLevel  NullProficiencyLevelEnum `db:"proficiency_level" json:"proficiency_level"`
	YearsOfExperience pgtype.Int4              `db:"years_of_experience" json:"years_of_experience"`
}

func (q *Queries) AddUserSkill(ctx context.Context, arg AddUserSkillParams) (UserSkill, error) {
	row := q.db.QueryRow(ctx, addUserSkill,
		arg.UserID,
		arg.SkillID,
		arg.ProficiencyLevel,
		arg.YearsOfExperience,
	)
	var i UserSkill
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SkillID,
		&i.ProficiencyLevel,
		&i.YearsOfExperience,
		&i.CreatedAt,
	)
	return i, err
}

const createContract = `-- name: CreateContract :one

INSERT INTO contracts (job_id, client_id, freelancer_id, proposal_id, title, description,
    contract_type, total_amount, hourly_rate, estimated_hours, start_date, end_date, status,
    terms_and_conditions, payment_terms)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15)
RETURNING id, job_id, client_id, freelancer_id, proposal_id, title, description, contract_type, total_amount, hourly_rate, estimated_hours, start_date, end_date, status, terms_and_conditions, payment_terms, created_at, updated_at, signed_by_client_at, signed_by_freelancer_at, completed_at
`

type CreateContractParams struct {
	JobID              int64                  `db:"job_id" json:"job_id"`
	ClientID           int64                  `db:"client_id" json:"client_id"`
	FreelancerID       int64                  `db:"freelancer_id" json:"freelancer_id"`
	ProposalID         pgtype.Int8            `db:"proposal_id" json:"proposal_id"`
	Title              string                 `db:"title" json:"title"`
	Description        pgtype.Text            `db:"description" json:"description"`
	ContractType       RateTypeEnum           `db:"contract_type" json:"contract_type"`
	TotalAmount        pgtype.Numeric         `db:"total_amount" json:"total_amount"`
	HourlyRate         pgtype.Numeric         `db:"hourly_rate" json:"hourly_rate"`
	EstimatedHours     pgtype.Int4            `db:"estimated_hours" json:"estimated_hours"`
	StartDate          pgtype.Date            `db:"start_date" json:"start_date"`
	EndDate            pgtype.Date            `db:"end_date" json:"end_date"`
	Status             NullContractStatusEnum `db:"status" json:"status"`
	TermsAndConditions pgtype.Text            `db:"terms_and_conditions" json:"terms_and_conditions"`
	PaymentTerms       NullPaymentTermsEnum   `db:"payment_terms" json:"payment_terms"`
}

// Contracts Queries
func (q *Queries) CreateContract(ctx context.Context, arg CreateContractParams) (Contract, error) {
	row := q.db.QueryRow(ctx, createContract,
		arg.JobID,
		arg.ClientID,
		arg.FreelancerID,
		arg.ProposalID,
		arg.Title,
		arg.Description,
		arg.ContractType,
		arg.TotalAmount,
		arg.HourlyRate,
		arg.EstimatedHours,
		arg.StartDate,
		arg.EndDate,
		arg.Status,
		arg.TermsAndConditions,
		arg.PaymentTerms,
	)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.ClientID,
		&i.FreelancerID,
		&i.ProposalID,
		&i.Title,
		&i.Description,
		&i.ContractType,
		&i.TotalAmount,
		&i.HourlyRate,
		&i.EstimatedHours,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.TermsAndConditions,
		&i.PaymentTerms,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SignedByClientAt,
		&i.SignedByFreelancerAt,
		&i.CompletedAt,
	)
	return i, err
}

const createDispute = `-- name: CreateDispute :one

INSERT INTO disputes (contract_id, raised_by, dispute_type, subject, description, amount_disputed, status)
VALUES ($1,$2,$3,$4,$5,$6,$7)
RETURNING id, contract_id, raised_by, dispute_type, subject, description, amount_disputed, status, resolution, resolved_by, created_at, updated_at, resolved_at
`

type CreateDisputeParams struct {
	ContractID     int64                 `db:"contract_id" json:"contract_id"`
	RaisedBy       int64                 `db:"raised_by" json:"raised_by"`
	DisputeType    DisputeTypeEnum       `db:"dispute_type" json:"dispute_type"`
	Subject        string                `db:"subject" json:"subject"`
	Description    string                `db:"description" json:"description"`
	AmountDisputed pgtype.Numeric        `db:"amount_disputed" json:"amount_disputed"`
	Status         NullDisputeStatusEnum `db:"status" json:"status"`
}

// Disputes Queries
func (q *Queries) CreateDispute(ctx context.Context, arg CreateDisputeParams) (Dispute, error) {
	row := q.db.QueryRow(ctx, createDispute,
		arg.ContractID,
		arg.RaisedBy,
		arg.DisputeType,
		arg.Subject,
		arg.Description,
		arg.AmountDisputed,
		arg.Status,
	)
	var i Dispute
	err := row.Scan(
		&i.ID,
		&i.ContractID,
		&i.RaisedBy,
		&i.DisputeType,
		&i.Subject,
		&i.Description,
		&i.AmountDisputed,
		&i.Status,
		&i.Resolution,
		&i.ResolvedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const createJob = `-- name: CreateJob :one

INSERT INTO jobs (client_id, category_id, title, description, requirements, budget_type,
    budget_min, budget_max, hourly_rate_min, hourly_rate_max, estimated_hours, project_duration,
    urgency, location_type, job_address, city, state, zip_code, country, latitude, longitude,
    preferred_start_date, deadline, visibility, status, is_featured)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26)
RETURNING id, client_id, category_id, title, description, requirements, budget_type, budget_min, budget_max, hourly_rate_min, hourly_rate_max, estimated_hours, project_duration, urgency, location_type, job_address, city, state, zip_code, country, latitude, longitude, preferred_start_date, deadline, status, visibility, applications_count, views_count, is_featured, created_at, updated_at, published_at, closed_at
`

type CreateJobParams struct {
	ClientID           int64                   `db:"client_id" json:"client_id"`
	CategoryID         pgtype.Int8             `db:"category_id" json:"category_id"`
	Title              string                  `db:"title" json:"title"`
	Description        string                  `db:"description" json:"description"`
	Requirements       pgtype.Text             `db:"requirements" json:"requirements"`
	BudgetType         BudgetTypeEnum          `db:"budget_type" json:"budget_type"`
	BudgetMin          pgtype.Numeric          `db:"budget_min" json:"budget_min"`
	BudgetMax          pgtype.Numeric          `db:"budget_max" json:"budget_max"`
	HourlyRateMin      pgtype.Numeric          `db:"hourly_rate_min" json:"hourly_rate_min"`
	HourlyRateMax      pgtype.Numeric          `db:"hourly_rate_max" json:"hourly_rate_max"`
	EstimatedHours     pgtype.Int4             `db:"estimated_hours" json:"estimated_hours"`
	ProjectDuration    NullProjectDurationEnum `db:"project_duration" json:"project_duration"`
	Urgency            NullUrgencyEnum         `db:"urgency" json:"urgency"`
	LocationType       LocationTypeEnum        `db:"location_type" json:"location_type"`
	JobAddress         pgtype.Text             `db:"job_address" json:"job_address"`
	City               pgtype.Text             `db:"city" json:"city"`
	State              pgtype.Text             `db:"state" json:"state"`
	ZipCode            pgtype.Text             `db:"zip_code" json:"zip_code"`
	Country            pgtype.Text             `db:"country" json:"country"`
	Latitude           pgtype.Numeric          `db:"latitude" json:"latitude"`
	Longitude          pgtype.Numeric          `db:"longitude" json:"longitude"`
	PreferredStartDate pgtype.Date             `db:"preferred_start_date" json:"preferred_start_date"`
	Deadline           pgtype.Date             `db:"deadline" json:"deadline"`
	Visibility         NullVisibilityEnum      `db:"visibility" json:"visibility"`
	Status             NullJobStatusEnum       `db:"status" json:"status"`
	IsFeatured         pgtype.Bool             `db:"is_featured" json:"is_featured"`
}

// Jobs Queries
func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.ClientID,
		arg.CategoryID,
		arg.Title,
		arg.Description,
		arg.Requirements,
		arg.BudgetType,
		arg.BudgetMin,
		arg.BudgetMax,
		arg.HourlyRateMin,
		arg.HourlyRateMax,
		arg.EstimatedHours,
		arg.ProjectDuration,
		arg.Urgency,
		arg.LocationType,
		arg.JobAddress,
		arg.City,
		arg.State,
		arg.ZipCode,
		arg.Country,
		arg.Latitude,
		arg.Longitude,
		arg.PreferredStartDate,
		arg.Deadline,
		arg.Visibility,
		arg.Status,
		arg.IsFeatured,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.CategoryID,
		&i.Title,
		&i.Description,
		&i.Requirements,
		&i.BudgetType,
		&i.BudgetMin,
		&i.BudgetMax,
		&i.HourlyRateMin,
		&i.HourlyRateMax,
		&i.EstimatedHours,
		&i.ProjectDuration,
		&i.Urgency,
		&i.LocationType,
		&i.JobAddress,
		&i.City,
		&i.State,
		&i.ZipCode,
		&i.Country,
		&i.Latitude,
		&i.Longitude,
		&i.PreferredStartDate,
		&i.Deadline,
		&i.Status,
		&i.Visibility,
		&i.ApplicationsCount,
		&i.ViewsCount,
		&i.IsFeatured,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.ClosedAt,
	)
	return i, err
}

const createMilestone = `-- name: CreateMilestone :one

INSERT INTO milestones (contract_id, title, description, amount, due_date, status, order_index)
VALUES ($1,$2,$3,$4,$5,$6,$7)
RETURNING id, contract_id, title, description, amount, due_date, status, order_index, created_at, updated_at, submitted_at, approved_at, paid_at
`

type CreateMilestoneParams struct {
	ContractID  int64                   `db:"contract_id" json:"contract_id"`
	Title       string                  `db:"title" json:"title"`
	Description pgtype.Text             `db:"description" json:"description"`
	Amount      pgtype.Numeric          `db:"amount" json:"amount"`
	DueDate     pgtype.Date             `db:"due_date" json:"due_date"`
	Status      NullMilestoneStatusEnum `db:"status" json:"status"`
	OrderIndex  pgtype.Int4             `db:"order_index" json:"order_index"`
}

// Milestones Queries
func (q *Queries) CreateMilestone(ctx context.Context, arg CreateMilestoneParams) (Milestone, error) {
	row := q.db.QueryRow(ctx, createMilestone,
		arg.ContractID,
		arg.Title,
		arg.Description,
		arg.Amount,
		arg.DueDate,
		arg.Status,
		arg.OrderIndex,
	)
	var i Milestone
	err := row.Scan(
		&i.ID,
		&i.ContractID,
		&i.Title,
		&i.Description,
		&i.Amount,
		&i.DueDate,
		&i.Status,
		&i.OrderIndex,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SubmittedAt,
		&i.ApprovedAt,
		&i.PaidAt,
	)
	return i, err
}

const createNotification = `-- name: CreateNotification :one

INSERT INTO notifications (user_id, title, message, type, related_entity_type, related_entity_id)
VALUES ($1,$2,$3,$4,$5,$6)
RETURNING id, user_id, title, message, type, related_entity_type, related_entity_id, is_read, is_email_sent, is_push_sent, created_at, read_at
`

type CreateNotificationParams struct {
	UserID            int64                `db:"user_id" json:"user_id"`
	Title             string               `db:"title" json:"title"`
	Message           string               `db:"message" json:"message"`
	Type              NotificationTypeEnum `db:"type" json:"type"`
	RelatedEntityType pgtype.Text          `db:"related_entity_type" json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8          `db:"related_entity_id" json:"related_entity_id"`
}

// Notifications Queries
func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createNotification,
		arg.UserID,
		arg.Title,
		arg.Message,
		arg.Type,
		arg.RelatedEntityType,
		arg.RelatedEntityID,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Message,
		&i.Type,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.IsRead,
		&i.IsEmailSent,
		&i.IsPushSent,
		&i.CreatedAt,
		&i.ReadAt,
	)
	return i, err
}

const createProposal = `-- name: CreateProposal :one

INSERT INTO proposals (job_id, freelancer_id, cover_letter, proposed_rate, rate_type,
    estimated_hours, delivery_time, availability_start_date, status, is_featured)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, job_id, freelancer_id, cover_letter, proposed_rate, rate_type, estimated_hours, delivery_time, availability_start_date, status, is_featured, created_at, updated_at, responded_at
`

type CreateProposalParams struct {
	JobID                 int64                  `db:"job_id" json:"job_id"`
	FreelancerID          int64                  `db:"freelancer_id" json:"freelancer_id"`
	CoverLetter           string                 `db:"cover_letter" json:"cover_letter"`
	ProposedRate          pgtype.Numeric         `db:"proposed_rate" json:"proposed_rate"`
	RateType              RateTypeEnum           `db:"rate_type" json:"rate_type"`
	EstimatedHours        pgtype.Int4            `db:"estimated_hours" json:"estimated_hours"`
	DeliveryTime          pgtype.Int4            `db:"delivery_time" json:"delivery_time"`
	AvailabilityStartDate pgtype.Date            `db:"availability_start_date" json:"availability_start_date"`
	Status                NullProposalStatusEnum `db:"status" json:"status"`
	IsFeatured            pgtype.Bool            `db:"is_featured" json:"is_featured"`
}

// Proposals Queries
func (q *Queries) CreateProposal(ctx context.Context, arg CreateProposalParams) (Proposal, error) {
	row := q.db.QueryRow(ctx, createProposal,
		arg.JobID,
		arg.FreelancerID,
		arg.CoverLetter,
		arg.ProposedRate,
		arg.RateType,
		arg.EstimatedHours,
		arg.DeliveryTime,
		arg.AvailabilityStartDate,
		arg.Status,
		arg.IsFeatured,
	)
	var i Proposal
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.FreelancerID,
		&i.CoverLetter,
		&i.ProposedRate,
		&i.RateType,
		&i.EstimatedHours,
		&i.DeliveryTime,
		&i.AvailabilityStartDate,
		&i.Status,
		&i.IsFeatured,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RespondedAt,
	)
	return i, err
}

const createReview = `-- name: CreateReview :one

INSERT INTO reviews (contract_id, reviewer_id, reviewee_id, rating, review_text, communication_rating,
    quality_rating, timeliness_rating, professionalism_rating, would_recommend, is_public, status)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12)
RETURNING id, contract_id, reviewer_id, reviewee_id, rating, review_text, communication_rating, quality_rating, timeliness_rating, professionalism_rating, would_recommend, is_public, status, created_at, updated_at
`

type CreateReviewParams struct {
	ContractID            int64                `db:"contract_id" json:"contract_id"`
	ReviewerID            int64                `db:"reviewer_id" json:"reviewer_id"`
	RevieweeID            int64                `db:"reviewee_id" json:"reviewee_id"`
	Rating                int32                `db:"rating" json:"rating"`
	ReviewText            pgtype.Text          `db:"review_text" json:"review_text"`
	CommunicationRating   pgtype.Int4          `db:"communication_rating" json:"communication_rating"`
	QualityRating         pgtype.Int4          `db:"quality_rating" json:"quality_rating"`
	TimelinessRating      pgtype.Int4          `db:"timeliness_rating" json:"timeliness_rating"`
	ProfessionalismRating pgtype.Int4          `db:"professionalism_rating" json:"professionalism_rating"`
	WouldRecommend        pgtype.Bool          `db:"would_recommend" json:"would_recommend"`
	IsPublic              pgtype.Bool          `db:"is_public" json:"is_public"`
	Status                NullReviewStatusEnum `db:"status" json:"status"`
}

// Reviews Queries
func (q *Queries) CreateReview(ctx context.Context, arg CreateReviewParams) (Review, error) {
	row := q.db.QueryRow(ctx, createReview,
		arg.ContractID,
		arg.ReviewerID,
		arg.RevieweeID,
		arg.Rating,
		arg.ReviewText,
		arg.CommunicationRating,
		arg.QualityRating,
		arg.TimelinessRating,
		arg.ProfessionalismRating,
		arg.WouldRecommend,
		arg.IsPublic,
		arg.Status,
	)
	var i Review
	err := row.Scan(
		&i.ID,
		&i.ContractID,
		&i.ReviewerID,
		&i.RevieweeID,
		&i.Rating,
		&i.ReviewText,
		&i.CommunicationRating,
		&i.QualityRating,
		&i.TimelinessRating,
		&i.ProfessionalismRating,
		&i.WouldRecommend,
		&i.IsPublic,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTimeLog = `-- name: CreateTimeLog :one

INSERT INTO time_logs (contract_id, freelancer_id, description, start_time, end_time, hours_logged,
    hourly_rate, total_amount, status)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)
RETURNING id, contract_id, freelancer_id, description, start_time, end_time, hours_logged, hourly_rate, total_amount, status, created_at, updated_at
`

type CreateTimeLogParams struct {
	ContractID   int64                 `db:"contract_id" json:"contract_id"`
	FreelancerID int64                 `db:"freelancer_id" json:"freelancer_id"`
	Description  pgtype.Text           `db:"description" json:"description"`
	StartTime    pgtype.Timestamptz    `db:"start_time" json:"start_time"`
	EndTime      pgtype.Timestamptz    `db:"end_time" json:"end_time"`
	HoursLogged  pgtype.Numeric        `db:"hours_logged" json:"hours_logged"`
	HourlyRate   pgtype.Numeric        `db:"hourly_rate" json:"hourly_rate"`
	TotalAmount  pgtype.Numeric        `db:"total_amount" json:"total_amount"`
	Status       NullTimeLogStatusEnum `db:"status" json:"status"`
}

// Time Logs Queries
func (q *Queries) CreateTimeLog(ctx context.Context, arg CreateTimeLogParams) (TimeLog, error) {
	row := q.db.QueryRow(ctx, createTimeLog,
		arg.ContractID,
		arg.FreelancerID,
		arg.Description,
		arg.StartTime,
		arg.EndTime,
		arg.HoursLogged,
		arg.HourlyRate,
		arg.TotalAmount,
		arg.Status,
	)
	var i TimeLog
	err := row.Scan(
		&i.ID,
		&i.ContractID,
		&i.FreelancerID,
		&i.Description,
		&i.StartTime,
		&i.EndTime,
		&i.HoursLogged,
		&i.HourlyRate,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, password_hash, first_name, last_name, user_type, timezone, status)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, email, password_hash, first_name, last_name, phone, profile_image_url, user_type, is_verified, email_verified, phone_verified, status, created_at, updated_at, last_login, timezone
`

type CreateUserParams struct {
	Email        string         `db:"email" json:"email"`
	PasswordHash string         `db:"password_hash" json:"password_hash"`
	FirstName    string         `db:"first_name" json:"first_name"`
	LastName     string         `db:"last_name" json:"last_name"`
	UserType     UserTypeEnum   `db:"user_type" json:"user_type"`
	Timezone     pgtype.Text    `db:"timezone" json:"timezone"`
	Status       NullStatusEnum `db:"status" json:"status"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.PasswordHash,
		arg.FirstName,
		arg.LastName,
		arg.UserType,
		arg.Timezone,
		arg.Status,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.ProfileImageUrl,
		&i.UserType,
		&i.IsVerified,
		&i.EmailVerified,
		&i.PhoneVerified,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLogin,
		&i.Timezone,
	)
	return i, err
}

const createUserPortfolio = `-- name: CreateUserPortfolio :one

INSERT INTO user_portfolios (user_id, title, description, project_url, image_url, completion_date,
    skills, is_featured, sort_order)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)
RETURNING id, user_id, title, description, project_url, image_url, completion_date, skills, is_featured, sort_order, created_at, updated_at
`

type CreateUserPortfolioParams struct {
	UserID         int64       `db:"user_id" json:"user_id"`
	Title          string      `db:"title" json:"title"`
	Description    pgtype.Text `db:"description" json:"description"`
	ProjectUrl     pgtype.Text `db:"project_url" json:"project_url"`
	ImageUrl       pgtype.Text `db:"image_url" json:"image_url"`
	CompletionDate pgtype.Date `db:"completion_date" json:"completion_date"`
	Skills         []byte      `db:"skills" json:"skills"`
	IsFeatured     pgtype.Bool `db:"is_featured" json:"is_featured"`
	SortOrder      pgtype.Int4 `db:"sort_order" json:"sort_order"`
}

// User Portfolios Queries
func (q *Queries) CreateUserPortfolio(ctx context.Context, arg CreateUserPortfolioParams) (UserPortfolio, error) {
	row := q.db.QueryRow(ctx, createUserPortfolio,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.ProjectUrl,
		arg.ImageUrl,
		arg.CompletionDate,
		arg.Skills,
		arg.IsFeatured,
		arg.SortOrder,
	)
	var i UserPortfolio
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.ProjectUrl,
		&i.ImageUrl,
		&i.CompletionDate,
		&i.Skills,
		&i.IsFeatured,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserProfile = `-- name: CreateUserProfile :one
INSERT INTO user_profiles (user_id, bio, hourly_rate, experience_level, availability, location_address,
    city, state, zip_code, country, latitude, longitude, service_radius, languages, website_url,
    linkedin_url, facebook_url, instagram_url)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
RETURNING id, user_id, bio, hourly_rate, experience_level, availability, location_address, city, state, zip_code, country, latitude, longitude, service_radius, languages, website_url, linkedin_url, facebook_url, instagram_url, created_at, updated_at
`

type CreateUserProfileParams struct {
	UserID          int64                   `db:"user_id" json:"user_id"`
	Bio             pgtype.Text             `db:"bio" json:"bio"`
	HourlyRate      pgtype.Numeric          `db:"hourly_rate" json:"hourly_rate"`
	ExperienceLevel NullExperienceLevelEnum `db:"experience_level" json:"experience_level"`
	Availability    NullAvailabilityEnum    `db:"availability" json:"availability"`
	LocationAddress pgtype.Text             `db:"location_address" json:"location_address"`
	City            pgtype.Text             `db:"city" json:"city"`
	State           pgtype.Text             `db:"state" json:"state"`
	ZipCode         pgtype.Text             `db:"zip_code" json:"zip_code"`
	Country         pgtype.Text             `db:"country" json:"country"`
	Latitude        pgtype.Numeric          `db:"latitude" json:"latitude"`
	Longitude       pgtype.Numeric          `db:"longitude" json:"longitude"`
	ServiceRadius   pgtype.Int4             `db:"service_radius" json:"service_radius"`
	Languages       []byte                  `db:"languages" json:"languages"`
	WebsiteUrl      pgtype.Text             `db:"website_url" json:"website_url"`
	LinkedinUrl     pgtype.Text             `db:"linkedin_url" json:"linkedin_url"`
	FacebookUrl     pgtype.Text             `db:"facebook_url" json:"facebook_url"`
	InstagramUrl    pgtype.Text             `db:"instagram_url" json:"instagram_url"`
}

func (q *Queries) CreateUserProfile(ctx context.Context, arg CreateUserProfileParams) (UserProfile, error) {
	row := q.db.QueryRow(ctx, createUserProfile,
		arg.UserID,
		arg.Bio,
		arg.HourlyRate,
		arg.ExperienceLevel,
		arg.Availability,
		arg.LocationAddress,
		arg.City,
		arg.State,
		arg.ZipCode,
		arg.Country,
		arg.Latitude,
		arg.Longitude,
		arg.ServiceRadius,
		arg.Languages,
		arg.WebsiteUrl,
		arg.LinkedinUrl,
		arg.FacebookUrl,
		arg.InstagramUrl,
	)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Bio,
		&i.HourlyRate,
		&i.ExperienceLevel,
		&i.Availability,
		&i.LocationAddress,
		&i.City,
		&i.State,
		&i.ZipCode,
		&i.Country,
		&i.Latitude,
		&i.Longitude,
		&i.ServiceRadius,
		&i.Languages,
		&i.WebsiteUrl,
		&i.LinkedinUrl,
		&i.FacebookUrl,
		&i.InstagramUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getJobByID = `-- name: GetJobByID :one
SELECT id, client_id, category_id, title, description, requirements, budget_type, budget_min, budget_max, hourly_rate_min, hourly_rate_max, estimated_hours, project_duration, urgency, location_type, job_address, city, state, zip_code, country, latitude, longitude, preferred_start_date, deadline, status, visibility, applications_count, views_count, is_featured, created_at, updated_at, published_at, closed_at FROM jobs WHERE id = $1
`

func (q *Queries) GetJobByID(ctx context.Context, id int64) (Job, error) {
	row := q.db.QueryRow(ctx, getJobByID, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.CategoryID,
		&i.Title,
		&i.Description,
		&i.Requirements,
		&i.BudgetType,
		&i.BudgetMin,
		&i.BudgetMax,
		&i.HourlyRateMin,
		&i.HourlyRateMax,
		&i.EstimatedHours,
		&i.ProjectDuration,
		&i.Urgency,
		&i.LocationType,
		&i.JobAddress,
		&i.City,
		&i.State,
		&i.ZipCode,
		&i.Country,
		&i.Latitude,
		&i.Longitude,
		&i.PreferredStartDate,
		&i.Deadline,
		&i.Status,
		&i.Visibility,
		&i.ApplicationsCount,
		&i.ViewsCount,
		&i.IsFeatured,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.ClosedAt,
	)
	return i, err
}

const getJobSkills = `-- name: GetJobSkills :many
SELECT id, job_id, skill_id, is_required, proficiency_level, created_at FROM job_skills WHERE job_id = $1
`

func (q *Queries) GetJobSkills(ctx context.Context, jobID int64) ([]JobSkill, error) {
	rows, err := q.db.Query(ctx, getJobSkills, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JobSkill
	for rows.Next() {
		var i JobSkill
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.SkillID,
			&i.IsRequired,
			&i.ProficiencyLevel,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProposalsByJobID = `-- name: GetProposalsByJobID :many
SELECT id, job_id, freelancer_id, cover_letter, proposed_rate, rate_type, estimated_hours, delivery_time, availability_start_date, status, is_featured, created_at, updated_at, responded_at FROM proposals WHERE job_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetProposalsByJobID(ctx context.Context, jobID int64) ([]Proposal, error) {
	rows, err := q.db.Query(ctx, getProposalsByJobID, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Proposal
	for rows.Next() {
		var i Proposal
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.FreelancerID,
			&i.CoverLetter,
			&i.ProposedRate,
			&i.RateType,
			&i.EstimatedHours,
			&i.DeliveryTime,
			&i.AvailabilityStartDate,
			&i.Status,
			&i.IsFeatured,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RespondedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, first_name, last_name, phone, profile_image_url, user_type, is_verified, email_verified, phone_verified, status, created_at, updated_at, last_login, timezone FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.ProfileImageUrl,
		&i.UserType,
		&i.IsVerified,
		&i.EmailVerified,
		&i.PhoneVerified,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLogin,
		&i.Timezone,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one

SELECT id, email, password_hash, first_name, last_name, phone, profile_image_url, user_type, is_verified, email_verified, phone_verified, status, created_at, updated_at, last_login, timezone FROM users WHERE id = $1
`

// Users Queries
func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.ProfileImageUrl,
		&i.UserType,
		&i.IsVerified,
		&i.EmailVerified,
		&i.PhoneVerified,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLogin,
		&i.Timezone,
	)
	return i, err
}

const getUserNotificationSettings = `-- name: GetUserNotificationSettings :one

SELECT id, user_id, email_job_posted, email_proposal_received, email_proposal_status, email_contract_updates, email_payment_updates, email_messages, email_reviews, push_job_posted, push_proposal_received, push_proposal_status, push_contract_updates, push_payment_updates, push_messages, push_reviews, sms_important_updates, created_at, updated_at FROM user_notification_settings WHERE user_id = $1
`

// User Notification Settings Queries
func (q *Queries) GetUserNotificationSettings(ctx context.Context, userID int64) (UserNotificationSetting, error) {
	row := q.db.QueryRow(ctx, getUserNotificationSettings, userID)
	var i UserNotificationSetting
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EmailJobPosted,
		&i.EmailProposalReceived,
		&i.EmailProposalStatus,
		&i.EmailContractUpdates,
		&i.EmailPaymentUpdates,
		&i.EmailMessages,
		&i.EmailReviews,
		&i.PushJobPosted,
		&i.PushProposalReceived,
		&i.PushProposalStatus,
		&i.PushContractUpdates,
		&i.PushPaymentUpdates,
		&i.PushMessages,
		&i.PushReviews,
		&i.SmsImportantUpdates,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserProfileByUserID = `-- name: GetUserProfileByUserID :one

SELECT id, user_id, bio, hourly_rate, experience_level, availability, location_address, city, state, zip_code, country, latitude, longitude, service_radius, languages, website_url, linkedin_url, facebook_url, instagram_url, created_at, updated_at FROM user_profiles WHERE user_id = $1
`

// User Profiles Queries
func (q *Queries) GetUserProfileByUserID(ctx context.Context, userID int64) (UserProfile, error) {
	row := q.db.QueryRow(ctx, getUserProfileByUserID, userID)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Bio,
		&i.HourlyRate,
		&i.ExperienceLevel,
		&i.Availability,
		&i.LocationAddress,
		&i.City,
		&i.State,
		&i.ZipCode,
		&i.Country,
		&i.Latitude,
		&i.Longitude,
		&i.ServiceRadius,
		&i.Languages,
		&i.WebsiteUrl,
		&i.LinkedinUrl,
		&i.FacebookUrl,
		&i.InstagramUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserSkills = `-- name: GetUserSkills :many

SELECT id, user_id, skill_id, proficiency_level, years_of_experience, created_at FROM user_skills WHERE user_id = $1 ORDER BY proficiency_level DESC
`

// User Skills Queries
func (q *Queries) GetUserSkills(ctx context.Context, userID int64) ([]UserSkill, error) {
	rows, err := q.db.Query(ctx, getUserSkills, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserSkill
	for rows.Next() {
		var i UserSkill
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SkillID,
			&i.ProficiencyLevel,
			&i.YearsOfExperience,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveCategories = `-- name: ListActiveCategories :many

SELECT id, name, description, icon_url, parent_id, is_active, sort_order, created_at FROM categories WHERE is_active = TRUE ORDER BY sort_order, name
`

// Categories Queries
func (q *Queries) ListActiveCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.Query(ctx, listActiveCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IconUrl,
			&i.ParentID,
			&i.IsActive,
			&i.SortOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOpenJobs = `-- name: ListOpenJobs :many
SELECT id, client_id, category_id, title, description, requirements, budget_type, budget_min, budget_max, hourly_rate_min, hourly_rate_max, estimated_hours, project_duration, urgency, location_type, job_address, city, state, zip_code, country, latitude, longitude, preferred_start_date, deadline, status, visibility, applications_count, views_count, is_featured, created_at, updated_at, published_at, closed_at FROM jobs WHERE status = 'open' ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListOpenJobsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListOpenJobs(ctx context.Context, arg ListOpenJobsParams) ([]Job, error) {
	rows, err := q.db.Query(ctx, listOpenJobs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.CategoryID,
			&i.Title,
			&i.Description,
			&i.Requirements,
			&i.BudgetType,
			&i.BudgetMin,
			&i.BudgetMax,
			&i.HourlyRateMin,
			&i.HourlyRateMax,
			&i.EstimatedHours,
			&i.ProjectDuration,
			&i.Urgency,
			&i.LocationType,
			&i.JobAddress,
			&i.City,
			&i.State,
			&i.ZipCode,
			&i.Country,
			&i.Latitude,
			&i.Longitude,
			&i.PreferredStartDate,
			&i.Deadline,
			&i.Status,
			&i.Visibility,
			&i.ApplicationsCount,
			&i.ViewsCount,
			&i.IsFeatured,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.ClosedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSavedJobsForUser = `-- name: ListSavedJobsForUser :many
SELECT id, user_id, job_id, created_at FROM saved_jobs WHERE user_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListSavedJobsForUserParams struct {
	UserID int64 `db:"user_id" json:"user_id"`
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListSavedJobsForUser(ctx context.Context, arg ListSavedJobsForUserParams) ([]SavedJob, error) {
	rows, err := q.db.Query(ctx, listSavedJobsForUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SavedJob
	for rows.Next() {
		var i SavedJob
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.JobID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSkillsByCategory = `-- name: ListSkillsByCategory :many

SELECT id, name, category_id, description, is_active, created_at FROM skills WHERE category_id = $1 AND is_active = TRUE ORDER BY name
`

// Skills Queries
func (q *Queries) ListSkillsByCategory(ctx context.Context, categoryID pgtype.Int8) ([]Skill, error) {
	rows, err := q.db.Query(ctx, listSkillsByCategory, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Skill
	for rows.Next() {
		var i Skill
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CategoryID,
			&i.Description,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markMessageRead = `-- name: MarkMessageRead :exec
UPDATE messages SET is_read = TRUE, read_at = now() WHERE id = $1
`

func (q *Queries) MarkMessageRead(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, markMessageRead, id)
	return err
}

const markNotificationRead = `-- name: MarkNotificationRead :exec
UPDATE notifications SET is_read = TRUE, read_at = now() WHERE id = $1
`

func (q *Queries) MarkNotificationRead(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, markNotificationRead, id)
	return err
}

const recordJobView = `-- name: RecordJobView :exec

INSERT INTO job_views (job_id, user_id, ip_address, user_agent) VALUES ($1, $2, $3, $4)
`

type RecordJobViewParams struct {
	JobID     int64       `db:"job_id" json:"job_id"`
	UserID    pgtype.Int8 `db:"user_id" json:"user_id"`
	IpAddress pgtype.Text `db:"ip_address" json:"ip_address"`
	UserAgent pgtype.Text `db:"user_agent" json:"user_agent"`
}

// Job Views Queries
func (q *Queries) RecordJobView(ctx context.Context, arg RecordJobViewParams) error {
	_, err := q.db.Exec(ctx, recordJobView,
		arg.JobID,
		arg.UserID,
		arg.IpAddress,
		arg.UserAgent,
	)
	return err
}

const recordTransaction = `-- name: RecordTransaction :one

INSERT INTO transactions (contract_id, milestone_id, payer_id, payee_id, amount, platform_fee,
    net_amount, transaction_type, payment_method, payment_gateway, gateway_transaction_id, status,
    description, processed_at)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14)
RETURNING id, contract_id, milestone_id, payer_id, payee_id, amount, platform_fee, net_amount, transaction_type, payment_method, payment_gateway, gateway_transaction_id, status, description, created_at, updated_at, processed_at
`

type RecordTransactionParams struct {
	ContractID           pgtype.Int8               `db:"contract_id" json:"contract_id"`
	MilestoneID          pgtype.Int8               `db:"milestone_id" json:"milestone_id"`
	PayerID              int64                     `db:"payer_id" json:"payer_id"`
	PayeeID              int64                     `db:"payee_id" json:"payee_id"`
	Amount               pgtype.Numeric            `db:"amount" json:"amount"`
	PlatformFee          pgtype.Numeric            `db:"platform_fee" json:"platform_fee"`
	NetAmount            pgtype.Numeric            `db:"net_amount" json:"net_amount"`
	TransactionType      NullTransactionTypeEnum   `db:"transaction_type" json:"transaction_type"`
	PaymentMethod        PaymentMethodEnum         `db:"payment_method" json:"payment_method"`
	PaymentGateway       pgtype.Text               `db:"payment_gateway" json:"payment_gateway"`
	GatewayTransactionID pgtype.Text               `db:"gateway_transaction_id" json:"gateway_transaction_id"`
	Status               NullTransactionStatusEnum `db:"status" json:"status"`
	Description          pgtype.Text               `db:"description" json:"description"`
	ProcessedAt          pgtype.Timestamptz        `db:"processed_at" json:"processed_at"`
}

// Transactions Queries
func (q *Queries) RecordTransaction(ctx context.Context, arg RecordTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, recordTransaction,
		arg.ContractID,
		arg.MilestoneID,
		arg.PayerID,
		arg.PayeeID,
		arg.Amount,
		arg.PlatformFee,
		arg.NetAmount,
		arg.TransactionType,
		arg.PaymentMethod,
		arg.PaymentGateway,
		arg.GatewayTransactionID,
		arg.Status,
		arg.Description,
		arg.ProcessedAt,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.ContractID,
		&i.MilestoneID,
		&i.PayerID,
		&i.PayeeID,
		&i.Amount,
		&i.PlatformFee,
		&i.NetAmount,
		&i.TransactionType,
		&i.PaymentMethod,
		&i.PaymentGateway,
		&i.GatewayTransactionID,
		&i.Status,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessedAt,
	)
	return i, err
}

const removeSavedJob = `-- name: RemoveSavedJob :exec
DELETE FROM saved_jobs WHERE user_id = $1 AND job_id = $2
`

type RemoveSavedJobParams struct {
	UserID int64 `db:"user_id" json:"user_id"`
	JobID  int64 `db:"job_id" json:"job_id"`
}

func (q *Queries) RemoveSavedJob(ctx context.Context, arg RemoveSavedJobParams) error {
	_, err := q.db.Exec(ctx, removeSavedJob, arg.UserID, arg.JobID)
	return err
}

const saveJob = `-- name: SaveJob :exec

INSERT INTO saved_jobs (user_id, job_id) VALUES ($1, $2) ON CONFLICT DO NOTHING
`

type SaveJobParams struct {
	UserID int64 `db:"user_id" json:"user_id"`
	JobID  int64 `db:"job_id" json:"job_id"`
}

// Saved Jobs Queries
func (q *Queries) SaveJob(ctx context.Context, arg SaveJobParams) error {
	_, err := q.db.Exec(ctx, saveJob, arg.UserID, arg.JobID)
	return err
}

const sendMessage = `-- name: SendMessage :one

INSERT INTO messages (contract_id, job_id, sender_id, recipient_id, subject, message, message_type)
VALUES ($1,$2,$3,$4,$5,$6,$7)
RETURNING id, contract_id, job_id, sender_id, recipient_id, subject, message, message_type, is_read, parent_message_id, created_at, read_at
`

type SendMessageParams struct {
	ContractID  pgtype.Int8         `db:"contract_id" json:"contract_id"`
	JobID       pgtype.Int8         `db:"job_id" json:"job_id"`
	SenderID    int64               `db:"sender_id" json:"sender_id"`
	RecipientID int64               `db:"recipient_id" json:"recipient_id"`
	Subject     pgtype.Text         `db:"subject" json:"subject"`
	Message     string              `db:"message" json:"message"`
	MessageType NullMessageTypeEnum `db:"message_type" json:"message_type"`
}

// Messages Queries
func (q *Queries) SendMessage(ctx context.Context, arg SendMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, sendMessage,
		arg.ContractID,
		arg.JobID,
		arg.SenderID,
		arg.RecipientID,
		arg.Subject,
		arg.Message,
		arg.MessageType,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ContractID,
		&i.JobID,
		&i.SenderID,
		&i.RecipientID,
		&i.Subject,
		&i.Message,
		&i.MessageType,
		&i.IsRead,
		&i.ParentMessageID,
		&i.CreatedAt,
		&i.ReadAt,
	)
	return i, err
}

const updateContractStatus = `-- name: UpdateContractStatus :one
UPDATE contracts SET status = $2, updated_at = now() WHERE id = $1 RETURNING id, job_id, client_id, freelancer_id, proposal_id, title, description, contract_type, total_amount, hourly_rate, estimated_hours, start_date, end_date, status, terms_and_conditions, payment_terms, created_at, updated_at, signed_by_client_at, signed_by_freelancer_at, completed_at
`

type UpdateContractStatusParams struct {
	ID     int64                  `db:"id" json:"id"`
	Status NullContractStatusEnum `db:"status" json:"status"`
}

func (q *Queries) UpdateContractStatus(ctx context.Context, arg UpdateContractStatusParams) (Contract, error) {
	row := q.db.QueryRow(ctx, updateContractStatus, arg.ID, arg.Status)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.ClientID,
		&i.FreelancerID,
		&i.ProposalID,
		&i.Title,
		&i.Description,
		&i.ContractType,
		&i.TotalAmount,
		&i.HourlyRate,
		&i.EstimatedHours,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.TermsAndConditions,
		&i.PaymentTerms,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SignedByClientAt,
		&i.SignedByFreelancerAt,
		&i.CompletedAt,
	)
	return i, err
}

const updateDisputeStatus = `-- name: UpdateDisputeStatus :one
UPDATE disputes SET status = $2, resolution = $3, resolved_by = $4, updated_at = now(), resolved_at = $5
WHERE id = $1
RETURNING id, contract_id, raised_by, dispute_type, subject, description, amount_disputed, status, resolution, resolved_by, created_at, updated_at, resolved_at
`

type UpdateDisputeStatusParams struct {
	ID         int64                 `db:"id" json:"id"`
	Status     NullDisputeStatusEnum `db:"status" json:"status"`
	Resolution pgtype.Text           `db:"resolution" json:"resolution"`
	ResolvedBy pgtype.Int8           `db:"resolved_by" json:"resolved_by"`
	ResolvedAt pgtype.Timestamptz    `db:"resolved_at" json:"resolved_at"`
}

func (q *Queries) UpdateDisputeStatus(ctx context.Context, arg UpdateDisputeStatusParams) (Dispute, error) {
	row := q.db.QueryRow(ctx, updateDisputeStatus,
		arg.ID,
		arg.Status,
		arg.Resolution,
		arg.ResolvedBy,
		arg.ResolvedAt,
	)
	var i Dispute
	err := row.Scan(
		&i.ID,
		&i.ContractID,
		&i.RaisedBy,
		&i.DisputeType,
		&i.Subject,
		&i.Description,
		&i.AmountDisputed,
		&i.Status,
		&i.Resolution,
		&i.ResolvedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const updateJobStatus = `-- name: UpdateJobStatus :one
UPDATE jobs SET status = $2, updated_at = now() WHERE id = $1 RETURNING id, client_id, category_id, title, description, requirements, budget_type, budget_min, budget_max, hourly_rate_min, hourly_rate_max, estimated_hours, project_duration, urgency, location_type, job_address, city, state, zip_code, country, latitude, longitude, preferred_start_date, deadline, status, visibility, applications_count, views_count, is_featured, created_at, updated_at, published_at, closed_at
`

type UpdateJobStatusParams struct {
	ID     int64             `db:"id" json:"id"`
	Status NullJobStatusEnum `db:"status" json:"status"`
}

func (q *Queries) UpdateJobStatus(ctx context.Context, arg UpdateJobStatusParams) (Job, error) {
	row := q.db.QueryRow(ctx, updateJobStatus, arg.ID, arg.Status)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.CategoryID,
		&i.Title,
		&i.Description,
		&i.Requirements,
		&i.BudgetType,
		&i.BudgetMin,
		&i.BudgetMax,
		&i.HourlyRateMin,
		&i.HourlyRateMax,
		&i.EstimatedHours,
		&i.ProjectDuration,
		&i.Urgency,
		&i.LocationType,
		&i.JobAddress,
		&i.City,
		&i.State,
		&i.ZipCode,
		&i.Country,
		&i.Latitude,
		&i.Longitude,
		&i.PreferredStartDate,
		&i.Deadline,
		&i.Status,
		&i.Visibility,
		&i.ApplicationsCount,
		&i.ViewsCount,
		&i.IsFeatured,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.ClosedAt,
	)
	return i, err
}

const updateProposalStatus = `-- name: UpdateProposalStatus :one
UPDATE proposals SET status = $2, updated_at = now() WHERE id = $1 RETURNING id, job_id, freelancer_id, cover_letter, proposed_rate, rate_type, estimated_hours, delivery_time, availability_start_date, status, is_featured, created_at, updated_at, responded_at
`

type UpdateProposalStatusParams struct {
	ID     int64                  `db:"id" json:"id"`
	Status NullProposalStatusEnum `db:"status" json:"status"`
}

func (q *Queries) UpdateProposalStatus(ctx context.Context, arg UpdateProposalStatusParams) (Proposal, error) {
	row := q.db.QueryRow(ctx, updateProposalStatus, arg.ID, arg.Status)
	var i Proposal
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.FreelancerID,
		&i.CoverLetter,
		&i.ProposedRate,
		&i.RateType,
		&i.EstimatedHours,
		&i.DeliveryTime,
		&i.AvailabilityStartDate,
		&i.Status,
		&i.IsFeatured,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RespondedAt,
	)
	return i, err
}

const updateTimeLogStatus = `-- name: UpdateTimeLogStatus :one
UPDATE time_logs SET status = $2, updated_at = now() WHERE id = $1 RETURNING id, contract_id, freelancer_id, description, start_time, end_time, hours_logged, hourly_rate, total_amount, status, created_at, updated_at
`

type UpdateTimeLogStatusParams struct {
	ID     int64                 `db:"id" json:"id"`
	Status NullTimeLogStatusEnum `db:"status" json:"status"`
}

func (q *Queries) UpdateTimeLogStatus(ctx context.Context, arg UpdateTimeLogStatusParams) (TimeLog, error) {
	row := q.db.QueryRow(ctx, updateTimeLogStatus, arg.ID, arg.Status)
	var i TimeLog
	err := row.Scan(
		&i.ID,
		&i.ContractID,
		&i.FreelancerID,
		&i.Description,
		&i.StartTime,
		&i.EndTime,
		&i.HoursLogged,
		&i.HourlyRate,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET first_name = $2, last_name = $3, phone = $4, profile_image_url = $5,
    user_type = $6, is_verified = $7, email_verified = $8, phone_verified = $9,
    status = $10, updated_at = now()
WHERE id = $1
RETURNING id, email, password_hash, first_name, last_name, phone, profile_image_url, user_type, is_verified, email_verified, phone_verified, status, created_at, updated_at, last_login, timezone
`

type UpdateUserParams struct {
	ID              int64          `db:"id" json:"id"`
	FirstName       string         `db:"first_name" json:"first_name"`
	LastName        string         `db:"last_name" json:"last_name"`
	Phone           pgtype.Text    `db:"phone" json:"phone"`
	ProfileImageUrl pgtype.Text    `db:"profile_image_url" json:"profile_image_url"`
	UserType        UserTypeEnum   `db:"user_type" json:"user_type"`
	IsVerified      pgtype.Bool    `db:"is_verified" json:"is_verified"`
	EmailVerified   pgtype.Bool    `db:"email_verified" json:"email_verified"`
	PhoneVerified   pgtype.Bool    `db:"phone_verified" json:"phone_verified"`
	Status          NullStatusEnum `db:"status" json:"status"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Phone,
		arg.ProfileImageUrl,
		arg.UserType,
		arg.IsVerified,
		arg.EmailVerified,
		arg.PhoneVerified,
		arg.Status,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.ProfileImageUrl,
		&i.UserType,
		&i.IsVerified,
		&i.EmailVerified,
		&i.PhoneVerified,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLogin,
		&i.Timezone,
	)
	return i, err
}

const updateUserNotificationSettings = `-- name: UpdateUserNotificationSettings :one
UPDATE user_notification_settings
SET email_job_posted = $2, email_proposal_received = $3, email_proposal_status = $4,
    email_contract_updates = $5, email_payment_updates = $6, email_messages = $7,
    email_reviews = $8, push_job_posted = $9, push_proposal_received = $10, push_proposal_status = $11,
    push_contract_updates = $12, push_payment_updates = $13, push_messages = $14, push_reviews = $15,
    sms_important_updates = $16, updated_at = now()
WHERE user_id = $1
RETURNING id, user_id, email_job_posted, email_proposal_received, email_proposal_status, email_contract_updates, email_payment_updates, email_messages, email_reviews, push_job_posted, push_proposal_received, push_proposal_status, push_contract_updates, push_payment_updates, push_messages, push_reviews, sms_important_updates, created_at, updated_at
`

type UpdateUserNotificationSettingsParams struct {
	UserID                int64       `db:"user_id" json:"user_id"`
	EmailJobPosted        pgtype.Bool `db:"email_job_posted" json:"email_job_posted"`
	EmailProposalReceived pgtype.Bool `db:"email_proposal_received" json:"email_proposal_received"`
	EmailProposalStatus   pgtype.Bool `db:"email_proposal_status" json:"email_proposal_status"`
	EmailContractUpdates  pgtype.Bool `db:"email_contract_updates" json:"email_contract_updates"`
	EmailPaymentUpdates   pgtype.Bool `db:"email_payment_updates" json:"email_payment_updates"`
	EmailMessages         pgtype.Bool `db:"email_messages" json:"email_messages"`
	EmailReviews          pgtype.Bool `db:"email_reviews" json:"email_reviews"`
	PushJobPosted         pgtype.Bool `db:"push_job_posted" json:"push_job_posted"`
	PushProposalReceived  pgtype.Bool `db:"push_proposal_received" json:"push_proposal_received"`
	PushProposalStatus    pgtype.Bool `db:"push_proposal_status" json:"push_proposal_status"`
	PushContractUpdates   pgtype.Bool `db:"push_contract_updates" json:"push_contract_updates"`
	PushPaymentUpdates    pgtype.Bool `db:"push_payment_updates" json:"push_payment_updates"`
	PushMessages          pgtype.Bool `db:"push_messages" json:"push_messages"`
	PushReviews           pgtype.Bool `db:"push_reviews" json:"push_reviews"`
	SmsImportantUpdates   pgtype.Bool `db:"sms_important_updates" json:"sms_important_updates"`
}

func (q *Queries) UpdateUserNotificationSettings(ctx context.Context, arg UpdateUserNotificationSettingsParams) (UserNotificationSetting, error) {
	row := q.db.QueryRow(ctx, updateUserNotificationSettings,
		arg.UserID,
		arg.EmailJobPosted,
		arg.EmailProposalReceived,
		arg.EmailProposalStatus,
		arg.EmailContractUpdates,
		arg.EmailPaymentUpdates,
		arg.EmailMessages,
		arg.EmailReviews,
		arg.PushJobPosted,
		arg.PushProposalReceived,
		arg.PushProposalStatus,
		arg.PushContractUpdates,
		arg.PushPaymentUpdates,
		arg.PushMessages,
		arg.PushReviews,
		arg.SmsImportantUpdates,
	)
	var i UserNotificationSetting
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EmailJobPosted,
		&i.EmailProposalReceived,
		&i.EmailProposalStatus,
		&i.EmailContractUpdates,
		&i.EmailPaymentUpdates,
		&i.EmailMessages,
		&i.EmailReviews,
		&i.PushJobPosted,
		&i.PushProposalReceived,
		&i.PushProposalStatus,
		&i.PushContractUpdates,
		&i.PushPaymentUpdates,
		&i.PushMessages,
		&i.PushReviews,
		&i.SmsImportantUpdates,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserProfile = `-- name: UpdateUserProfile :one
UPDATE user_profiles
SET bio = $2, hourly_rate = $3, experience_level = $4, availability = $5, location_address = $6,
    city = $7, state = $8, zip_code = $9, country = $10, latitude = $11, longitude = $12,
    service_radius = $13, languages = $14, website_url = $15, linkedin_url = $16,
    facebook_url = $17, instagram_url = $18, updated_at = now()
WHERE user_id = $1
RETURNING id, user_id, bio, hourly_rate, experience_level, availability, location_address, city, state, zip_code, country, latitude, longitude, service_radius, languages, website_url, linkedin_url, facebook_url, instagram_url, created_at, updated_at
`

type UpdateUserProfileParams struct {
	UserID          int64                   `db:"user_id" json:"user_id"`
	Bio             pgtype.Text             `db:"bio" json:"bio"`
	HourlyRate      pgtype.Numeric          `db:"hourly_rate" json:"hourly_rate"`
	ExperienceLevel NullExperienceLevelEnum `db:"experience_level" json:"experience_level"`
	Availability    NullAvailabilityEnum    `db:"availability" json:"availability"`
	LocationAddress pgtype.Text             `db:"location_address" json:"location_address"`
	City            pgtype.Text             `db:"city" json:"city"`
	State           pgtype.Text             `db:"state" json:"state"`
	ZipCode         pgtype.Text             `db:"zip_code" json:"zip_code"`
	Country         pgtype.Text             `db:"country" json:"country"`
	Latitude        pgtype.Numeric          `db:"latitude" json:"latitude"`
	Longitude       pgtype.Numeric          `db:"longitude" json:"longitude"`
	ServiceRadius   pgtype.Int4             `db:"service_radius" json:"service_radius"`
	Languages       []byte                  `db:"languages" json:"languages"`
	WebsiteUrl      pgtype.Text             `db:"website_url" json:"website_url"`
	LinkedinUrl     pgtype.Text             `db:"linkedin_url" json:"linkedin_url"`
	FacebookUrl     pgtype.Text             `db:"facebook_url" json:"facebook_url"`
	InstagramUrl    pgtype.Text             `db:"instagram_url" json:"instagram_url"`
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (UserProfile, error) {
	row := q.db.QueryRow(ctx, updateUserProfile,
		arg.UserID,
		arg.Bio,
		arg.HourlyRate,
		arg.ExperienceLevel,
		arg.Availability,
		arg.LocationAddress,
		arg.City,
		arg.State,
		arg.ZipCode,
		arg.Country,
		arg.Latitude,
		arg.Longitude,
		arg.ServiceRadius,
		arg.Languages,
		arg.WebsiteUrl,
		arg.LinkedinUrl,
		arg.FacebookUrl,
		arg.InstagramUrl,
	)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Bio,
		&i.HourlyRate,
		&i.ExperienceLevel,
		&i.Availability,
		&i.LocationAddress,
		&i.City,
		&i.State,
		&i.ZipCode,
		&i.Country,
		&i.Latitude,
		&i.Longitude,
		&i.ServiceRadius,
		&i.Languages,
		&i.WebsiteUrl,
		&i.LinkedinUrl,
		&i.FacebookUrl,
		&i.InstagramUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
